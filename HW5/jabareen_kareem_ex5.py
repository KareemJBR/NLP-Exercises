from sys import argv
import numpy as np
import math


def get_tree(indentation_spaces, words, list_dict, first, last):
    """Help function used for creating the generation tree for a sentence in grammar based on CKY algorithm."""
    tree_res = ' ' * indentation_spaces
    my_value = list_dict[str(first) + ',' + str(last)]

    if len(my_value) == 1:      # stop condition
        return tree_res + my_value[0] + ' > ' + words[first] + '\n'

    tree_res += my_value[0] + '\n'
    # a tap is 4 spaces, that is why we add 4 the next call
    tree_res += get_tree(indentation_spaces + 4, words, list_dict, first, my_value[2])
    return tree_res + get_tree(indentation_spaces + 4, words, list_dict, my_value[2], last)


def run_CKY(sentence, grammar):
    """
    Finds the sequence of rules with the highest probability for creating a sentence.

    :param sentence: The sentence to generate from the grammar.
    :param grammar: The grammar sent as text with a single rule in each line.
    :return: Returns the tree for generating the sentence and the probability of the sentence in the language if the
        sentence can be generated by the grammar. Otherwise, the function returns a sentence indicating the sentence
        does not belong to the language created by the received grammar.
    """

    cky_res = ''
    non_terminals, j = {}, 0    # will use the dictionary for storing the non-terminals

    for rule in grammar:
        rule_list = rule.split()    # as given in the exercise, space key is the only separator in the file

        for _, item in enumerate(rule_list):
            if item not in non_terminals and item.isalpha() and item.isupper():
                non_terminals[item] = j     # non-terminals are only upper case letters based on CNF
                j += 1

    my_list_dict, words = {}, sentence.split()
    non_terminals_num, sen_len = len(non_terminals), len(words)

    my_chart = np.zeros(shape=(sen_len, sen_len + 1, non_terminals_num))    # the chart for CKY algorithm

    # implementing CKY
    for j in range(1, sen_len + 1):
        for rule in grammar:
            rule_list = rule.split()
            if rule_list[3] == words[j - 1]:
                my_chart[j - 1, j, non_terminals[rule_list[1]]] = rule_list[0]
                indices = [j - 1, j]
                left_non_term = [rule_list[1]]
                my_list_dict[str(indices[0]) + ',' + str(indices[1])] = left_non_term

        for i in range(j - 2, -1, -1):
            for k in range(i + 1, j):
                first_non_terminal, second_non_terminal = [], []

                for non_terminal in non_terminals:
                    if my_chart[i, k, non_terminals[non_terminal]] > 0:
                        first_non_terminal.append(non_terminal)
                    if my_chart[k, j, non_terminals[non_terminal]] > 0:
                        second_non_terminal.append(non_terminal)

                for first_non_term in first_non_terminal:
                    for second_non_term in second_non_terminal:
                        for rule in grammar:
                            rule_list = rule.split()
                            non_terminals_num = len(rule_list)
                            my_right = rule_list[non_terminals_num - 2] + ' ' + rule_list[non_terminals_num - 1]
                            current_right = first_non_term + " " + second_non_term

                            if current_right == my_right:
                                my_prob = float(rule_list[0]) * my_chart[i, k, non_terminals[first_non_term]] * \
                                          my_chart[k, j, non_terminals[second_non_term]]

                                if my_prob > my_chart[i, j, non_terminals[rule_list[1]]]:
                                    indices = [i, j]
                                    subtree_data = [rule_list[1], first_non_term, k, second_non_term]

                                    my_list_dict[str(indices[0]) + ',' + str(indices[1])] = subtree_data
                                    # storing probability in order to print the log of the highest probability
                                    my_chart[i, j, non_terminals[rule_list[1]]] = my_prob

    # we shall return the final result as text

    cky_res += 'Sentence: ' + sentence
    if my_chart[0, sen_len, non_terminals['S']] == 0:   # sentence cannot be created by the grammar
        return cky_res + ' *** This sentence is not a member of the language generated by the grammar *** \n\n'

    cky_res += 'Parsing:\n'
    cky_res += get_tree(0, words, my_list_dict, 0, sen_len)
    return cky_res + '\nLog Probability: ' + str(math.log(my_chart[0, sen_len, non_terminals['S']])) + '\n\n'


if __name__ == '__main__':

    input_grammar = argv[1]         # The name of the file that contains the probabilistic grammar
    input_sentences = argv[2]       # The name of the file that contains the input sentences (tests)
    output_trees = argv[3]          # The name of the output file

    output_text = ''

    with open(input_grammar, 'r') as jabber:    # reading grammar rules
        grammar_rules = jabber.readlines()

    with open(input_sentences, 'r') as jabber:  # reading test sentences
        sentences = jabber.readlines()

    for sen in sentences:
        output_text += run_CKY(sen, grammar_rules)      # creating the output text

    with open(output_trees, 'w', encoding='utf-8') as jabber:   # writing the results into a text file in UTF-8
        jabber.write(output_text)
